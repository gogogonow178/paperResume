-- Enable UUID extension (usually enabled by default, but good to ensure)
create extension if not exists "uuid-ossp";

-- 1. Create public.users table (Syncs with auth.users)
create table public.users (
  id uuid references auth.users not null primary key,
  email text,
  credits int default 5, -- Give 5 free credits on sign up
  is_paid boolean default false,
  created_at timestamptz default now()
);

-- 2. Create usage_logs table
create table public.usage_logs (
  id bigint generated by default as identity primary key,
  user_id uuid references public.users(id),
  feature text not null,
  input_tokens int,
  output_tokens int,
  model text,
  created_at timestamptz default now()
);

-- 3. Set up Row Level Security (RLS) - Security Policies
alter table public.users enable row level security;
alter table public.usage_logs enable row level security;

-- Users can read their own data
create policy "Users can view own profile" 
on public.users for select 
using ( auth.uid() = id );

-- Users can view their own usage logs
create policy "Users can view own usage logs" 
on public.usage_logs for select 
using ( auth.uid() = user_id );

-- 4. Create a function to handle new user signup (Auto-create public.user)
create or replace function public.handle_new_user() 
returns trigger as $$
begin
  insert into public.users (id, email, credits)
  values (new.id, new.email, 5);
  return new;
end;
$$ language plpgsql security definer;

-- 5. Trigger the function every time a user signs up
create or replace trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- 6. Atomic Credit Deduction Function (For backend use)
create or replace function decrement_credits(user_id uuid, amount int)
returns int
language plpgsql
security definer
as $$
declare
  current_credits int;
  new_credits int;
begin
  -- Lock the row for update to prevent race conditions
  select credits into current_credits from public.users where id = user_id for update;
  
  if current_credits >= amount then
    new_credits := current_credits - amount;
    update public.users set credits = new_credits where id = user_id;
    return new_credits; -- Success, return remaining credits
  else
    return -1; -- Failure, not enough credits
  end if;
end;
$$;
